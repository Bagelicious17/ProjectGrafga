<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fauzan Advanture</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        /* --- Basic Setup --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            /* Menggunakan Font dari Code Kedua */
            font-family: 'Press Start 2P', 'Courier New', monospace;
            background-color: #111;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        /* --- Game Container --- */
        #game-container {
            position: relative;
            border: 4px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            background-color: #1a2a1a; /* Dark green background */
        }

        /* --- UI Overlays --- */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.85); /* Sedikit lebih gelap agar tulisan jelas */
            color: #fff;
            text-align: center;
            z-index: 10;
            backdrop-filter: blur(5px);
            padding: 20px;
        }

        /* Update: Allow scrolling in overlays if content is too tall (like Almanac) */
        #almanac-screen {
            justify-content: center; /* Center vertically unless overflowing */
            overflow-y: auto; /* Enable scroll if needed */
        }

        .hidden {
            display: none !important;
        }

        /* --- Text and Titles --- */
        h1, h2 {
            text-shadow: 4px 4px 0px #922b21;
            margin-bottom: 20px;
            text-transform: uppercase;
            line-height: 1.5;
        }

        h1 { font-size: 2.5rem; color: #e74c3c; }
        h2 { font-size: 1.5rem; color: #f1c40f; margin-top: 10px;}
        p { margin-bottom: 10px; font-size: 0.8rem; line-height: 1.5; }

        /* --- Buttons --- */
        button {
            background: #e74c3c;
            color: #fff;
            border: 4px solid #c0392b;
            padding: 15px 25px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 6px 0 #7c1e15;
            margin-top: 20px;
            transition: transform 0.1s;
        }

        button:hover {
            background: #ff6b5a;
            transform: translateY(-2px);
            margin-top: 18px; margin-bottom: 2px;
        }
        
        button:active {
            transform: translateY(6px);
            box-shadow: 0 0 0 #7c1e15;
            margin-top: 26px; margin-bottom: -6px;
        }

        /* =========================================
            STYLE KHUSUS: CHARACTER SELECTION SCREEN
            (Diambil dari Code Kedua)
            ========================================= */
        
        /* Background Khusus Menu Select */
        #character-selection {
            background-color: #050505;
            overflow: hidden; /* Penting untuk animasi obor */
        }
        
        .bg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #0a0a0c;
            background-image: 
                linear-gradient(335deg, rgba(20,20,25,0.6) 23px, transparent 23px),
                linear-gradient(155deg, rgba(30,30,40,0.6) 23px, transparent 23px);
            background-size: 58px 58px;
            z-index: -10;
        }

        .bg-torch {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                radial-gradient(circle at 5% 50%, rgba(255, 100, 0, 0.3), transparent 40%),
                radial-gradient(circle at 95% 50%, rgba(255, 100, 0, 0.3), transparent 40%);
            z-index: -9;
            animation: torchFlicker 3s infinite alternate;
        }

        .bg-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, #000 95%);
            z-index: -5;
            pointer-events: none;
        }

        @keyframes torchFlicker { 0% { opacity: 0.8; } 100% { opacity: 1; } }

        /* Container Kartu */
        .card-container {
            display: flex; gap: 20px; z-index: 5;
            align-items: flex-end; justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        /* Animasi Wrapper Kartu */
        .card-wrapper {
            position: relative;
            display: flex; flex-direction: column; align-items: center;
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .card-wrapper:hover {
            transform: translateY(-20px) scale(1.05); z-index: 20;
        }

        /* Desain Fisik Kartu */
        .card {
            width: 200px; height: 320px;
            background: linear-gradient(180deg, #3c3430 0%, #1e1a18 100%);
            border-radius: 10px;
            position: relative;
            display: flex; flex-direction: column; align-items: center; padding: 10px;
            border: 4px solid #8c7a6b;
            box-shadow: inset 0 0 0 3px #110d0a, 0 0 0 4px #4a3f38, 0 20px 40px rgba(0,0,0,0.9);
            cursor: pointer; transition: all 0.3s ease;
        }

        /* Hover Glow Effect */
        .card-wrapper:hover .card {
            border-color: #ffb300 !important;
            box-shadow: inset 0 0 0 3px #110d0a, 0 0 0 5px #ffb300, 0 0 40px rgba(255, 140, 0, 0.5);
        }

        /* Portrait Area */
        .portrait-bg {
            width: 100%; height: 140px;
            background-color: #2a2320;
            background-image: radial-gradient(circle, #3c322e 10%, transparent 10%);
            background-size: 10px 10px;
            border: 3px inset #1a1512; border-radius: 6px;
            margin-bottom: 10px;
            display: flex; justify-content: center; align-items: center;
            position: relative; overflow: hidden;
        }

        /* Character Sprite Animation */
        .character-sprite {
            width: 90%; height: 90%;
            image-rendering: pixelated; object-fit: contain;
            filter: drop-shadow(5px 5px 2px rgba(0,0,0,0.6));
            animation: idleFloat 3s ease-in-out infinite;
        }

        @keyframes idleFloat {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-5px) scale(1.02); }
        }

        /* Weapon Icon Box */
        .weapon-box {
            position: absolute; bottom: 5px; right: 5px;
            width: 36px; height: 36px; background: #1a1512;
            border: 2px solid #7c6a5b; border-radius: 4px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 2px 2px 5px #000; z-index: 5;
        }
        .weapon-sprite { width: 80%; height: 80%; image-rendering: pixelated; object-fit: contain; }

        /* Typography Kartu */
        .char-name { font-size: 0.9rem; margin-bottom: 5px; color: #ffebd0; text-shadow: 2px 2px 0 #000; text-transform: uppercase; text-align: center;}
        .char-desc { font-size: 0.5rem; color: #a89f94; margin-bottom: 15px; font-family: monospace; font-weight: bold; text-align: center; }

        /* Stats Bars */
        .stats-container { width: 100%; padding: 0 5px; }
        .stat-row { display: flex; align-items: center; justify-content: space-between; font-size: 0.55rem; margin-bottom: 6px; color: #c7b299; text-transform: uppercase; }
        .stat-bar-container { width: 50%; height: 6px; background: #0f0c0a; border: 2px solid #3c322e; }
        .stat-fill { height: 100%; background: #c0392b; width: 0%; }
        .stat-fill.speed { background: #e1b12c; }

        /* Pedestal & Gem */
        .pedestal {
            margin-top: -6px; width: 190px; height: 35px;
            background: #5c4e44; border: 4px solid #2e2724;
            clip-path: polygon(12% 0, 88% 0, 100% 100%, 0% 100%);
            display: flex; justify-content: center; align-items: center;
            z-index: -1; position: relative;
        }
        .gem {
            width: 14px; height: 14px; background: #c0392b;
            transform: rotate(45deg); border: 2px solid #1a0f0a;
            box-shadow: inset 2px 2px 4px rgba(255,255,255,0.6), 0 0 10px #c0392b;
        }

        /* --- Level-Up & Almanac Styles (Existing modified) --- */
        #level-up-screen .upgrade-card,
        .almanac-card {
            background: rgba(40, 40, 40, 0.9);
            border: 2px solid #555;
            padding: 20px;
            margin: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 250px;
        }

        #level-up-screen .upgrade-card:hover,
        .almanac-card:hover {
            border-color: #e74c3c;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }

        .upgrade-card h3 {
            color: #2ecc71; /* Green for upgrade title */
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .upgrade-card .level {
             color: #f1c40f; /* Yellow for level */
             font-size: 0.8rem;
        }

        .upgrade-card p {
            font-size: 0.7rem;
            color: #bdc3c7;
        }

        #upgrade-options {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        
        /* --- Game Over Screen --- */
        #game-over-stats {
            background: rgba(20, 20, 20, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #333;
            width: 80%;
            max-width: 400px;
        }

        #game-over-stats p {
            font-size: 1rem;
            display: flex;
            justify-content: space-between;
        }
         #game-over-stats p span:first-child {
            color: #95a5a6;
        }

        /* Almanac - RESIZED to fit screen */
        .almanac-content {
            display: flex;
            gap: 15px;
            width: 95%;
            max-width: 900px; /* Reduced width */
            padding: 15px;
            background: radial-gradient(circle at top, rgba(70, 40, 20, 0.35), rgba(0, 0, 0, 0.95));
            border-radius: 12px;
            border: 2px solid #444;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.8);
            align-items: flex-start; /* Align top */
            max-height: 80vh; /* Prevent it from being taller than screen */
        }
        .almanac-left {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            padding: 8px;
            background: rgba(10, 10, 15, 0.95);
            border-radius: 10px;
            border: 2px solid #333;
            max-height: 350px; /* Reduced Height to fit screen */
            overflow-y: auto;
        }
        .almanac-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(12, 12, 18, 0.98);
            border-radius: 10px;
            border: 2px solid #555;
        }
        .almanac-card {
            background: radial-gradient(circle at top, rgba(90, 90, 90, 0.95), rgba(30, 30, 30, 0.98));
            border: 2px solid #555;
            padding: 6px;
            margin: 2px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100px; /* Smaller card */
            box-shadow: 0 4px 0 #222;
        }
        .almanac-card:hover {
            border-color: #f1c40f;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.7);
        }
        .almanac-card.selected {
            border-color: #f1c40f;
            box-shadow: 0 0 10px rgba(241, 196, 15, 0.8);
        }
        .almanac-thumb {
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 2px solid #777;
            background: #222;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-radius: 6px;
        }
        .almanac-thumb img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            image-rendering: pixelated;
        }
        /* Resized Animation Container */
        #almanac-anim-container {
            width: 180px; /* Much smaller */
            height: 180px;
            border: 3px solid #777;
            background: radial-gradient(circle at center, #222 0%, #111 70%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
        }
        #almanac-anim-canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        #almanac-lore {
            max-width: 100%;
            background: linear-gradient(135deg, rgba(30, 22, 15, 0.97), rgba(10, 8, 5, 0.99));
            padding: 10px;
            border: 2px solid #8e6e3b;
            border-radius: 10px;
            color: #e0d2b0;
            text-align: left;
            font-size: 0.65rem; /* Smaller font for lore */
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
        }
        #almanac-title {
            font-size: 1rem;
            color: #e67e22;
            margin: 0;
        }

        /* In-game options (top-right) */
        .play-options {
            position: absolute;
            bottom: 8px;
            right: 8px;
            z-index: 6;
            background: rgba(0,0,0,0.4);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 8px 10px;
            color: #fff;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .play-options label { display: flex; align-items: center; gap: 6px; font-size: 10px; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <div id="play-options" class="play-options hidden">
            <label><input id="toggle-char-hitbox" type="checkbox"> Character hitbox</label>
            <label><input id="toggle-weapon-hitbox" type="checkbox"> Weapon hitbox</label>
        </div>

        <div id="main-menu" class="ui-overlay">
            <h1>Fauzan Adventure</h1>
            <p>Selamatkan Fauzan Dari Makhluk Kegelapan</p>
            <p><strong>Kontrol:</strong> WASD atau anak panah.</p>
            <button id="start-game-button">Start Game</button>
            <button id="almanac-button">Almanac</button>
        </div>

        <div id="character-selection" class="ui-overlay hidden">
            <div class="bg-layer"></div>
            <div class="bg-torch"></div>
            <div class="bg-vignette"></div>

            <h1 style="z-index: 20;">Pilih Korbanmu!</h1>
            
            <div id="character-options" class="card-container">
                <!-- Cards generated via JS -->
            </div>
        </div>

        <div id="almanac-screen" class="ui-overlay hidden">
            <h2>Almanac</h2>
            <div id="almanac-content" class="almanac-content">
                <div id="almanac-left" class="almanac-left"></div>
                <div id="almanac-right" class="almanac-right">
                    <h3 id="almanac-title"></h3>
                    <div id="almanac-anim-container">
                        <canvas id="almanac-anim-canvas" width="256" height="256"></canvas>
                    </div>
                    <div id="almanac-lore"></div>
                </div>
            </div>
            <button id="almanac-back-button" style="padding: 10px 20px; font-size: 0.8rem;">Back</button>
        </div>

        <div id="pause-screen" class="ui-overlay hidden">
            <h2>Paused</h2>
            <button id="resume-button">Resume</button>
            <button id="quit-button">Quit to Menu</button>
        </div>

        <div id="level-up-screen" class="ui-overlay hidden">
            <h2 style="color:#f1c40f">Naik Level!</h2>
            <p>Pilih Sembako:</p>
            <div id="upgrade-options">
                <!-- Upgrades generated via JS -->
            </div>
        </div>
        
        <div id="game-over-screen" class="ui-overlay hidden">
            <h2 style="color:#c0392b">Skill Issue</h2>
            <div id="game-over-stats">
                 <!-- Stats via JS -->
            </div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <script>
    // --- UTILITY FUNCTIONS ---
    const rand = (min, max) => Math.random() * (max - min) + min;
    const randInt = (min, max) => Math.floor(rand(min, max + 1));
    const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];

    // --- GAME CONFIGURATION ---
    const CONFIG = {
        PLAYER_SPEED: 200,
        PLAYER_HEALTH: 100,
        XP_TO_LEVEL: 100,
        XP_GROWTH: 1.5,
        MAGNET_RADIUS: 100,
        GAME_DURATION: 30 * 60 * 1000, // 30 minutes in ms
        CHEST_SPAWN_INTERVAL: 25, // seconds
        CHEST_MAX_ON_FIELD: 3,
        PROPS_COUNT: 200,
    };

    // --- ASSET AND DATA DEFINITIONS ---

    // Characters (UPDATED with themeColor for the UI)
    const CHARACTERS = [
        {
            name: "Fauzan",
            spriteColor: 'silver',
            sprite: 'assets/sprites/characters/Fauzan.png',
            animations: { walk: { src: 'assets/sprites/characters/Fauzan_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 8 } },
            stats: { speed: 200, maxHealth: 100, magnet: 1, luck: 1 },
            startingWeapon: "Sword",
            themeColor: "#c0392b" // Red
        },
        {
            name: "Suryanti",
            spriteColor: 'aqua',
            sprite: 'assets/sprites/characters/Mage.png',
            animations: { walk: { src: 'assets/sprites/characters/Mage_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 8 } },
            stats: { speed: 180, maxHealth: 80, magnet: 1.2, luck: 1.1 },
            startingWeapon: "MagicWand",
            themeColor: "#3498db" // Blue
        },
        {
            name: "Adit",
            spriteColor: '#2ecc71',
            sprite: 'assets/sprites/characters/Ranger.png',
            animations: { walk: { src: 'assets/sprites/characters/Ranger_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 10 } },
            stats: { speed: 220, maxHealth: 90, magnet: 1, luck: 1.2 },
            startingWeapon: "Axe",
            themeColor: "#2ecc71" // Green
        },
        {
            name: "Bagas Dribble",
            spriteColor: '#e67e22',
            sprite: 'assets/sprites/characters/Bagas.png',
            animations: { walk: { src: 'assets/sprites/characters/Bagas_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 8 } },
            stats: { speed: 210, maxHealth: 90, magnet: 1, luck: 1 },
            startingWeapon: "Bouncer",
            themeColor: "#e67e22" // Orange
        }
    ];

    // Weapons
    const WEAPONS = {
        Sword: {
            name: "Sword",
            type: 'attack',
            attackSprite: 'assets/sprites/weapons/sword.png',
            levels: [
                { cooldown: 1.5, damage: 10, area: 1, amount: 1, info: "Attacks horizontally." },
                { damage: 15, info: "+5 Damage" },
                { amount: 2, info: "Attacks both sides" },
                { area: 1.2, info: "+20% Area" },
                { damage: 20, info: "+5 Damage" },
                { cooldown: 1.2, info: "-20% Cooldown" },
            ]
        },
        MagicWand: {
            name: "Petir Magic",
            type: 'projectile',
            projectile: { speed: 300, size: 20, pierce: 0, lifespan: 1.5, sprite: 'assets/sprites/projectiles/magic_bolt.png' },
            levels: [
                { cooldown: 1, damage: 10, amount: 1, info: "Fires at nearest enemy." },
                { amount: 2, info: "+1 Projectile" },
                { damage: 15, info: "+5 Damage" },
                { cooldown: 0.8, info: "-20% Cooldown" },
                { amount: 3, info: "+1 Projectile" },
                { damage: 25, info: "+10 Damage" },
            ]
        },
        Axe: {
            name: "Kapak Suci",
            type: 'projectile',
            projectile: { speed: 200, size: 30, pierce: 2, arc: true, lifespan: 2, sprite: 'assets/sprites/projectiles/axe.png' },
            levels: [
                { cooldown: 2.5, damage: 25, amount: 1, info: "Throws an arcing axe." },
                { amount: 2, info: "+1 Projectile" },
                { damage: 35, info: "+10 Damage" },
                { area: 1.2, info: "+20% Area" },
                { cooldown: 2.0, info: "-20% Cooldown" },
                { amount: 3, info: "+1 Projectile" },
            ]
        },
        Bouncer: {
            name: "Bola  Memantul",
            type: 'projectile',
            projectile: { speed: 280, size: 22, pierce: 0, lifespan: 2, sprite: 'assets/sprites/projectiles/bouncer.png', bounce: true },
            levels: [
                { cooldown: 1, damage: 12, amount: 2, lifespan: 2, info: "Bouncing shots." },
                { lifespan: 2.5, info: "+0.5s Duration" },
                { damage: 18, info: "+6 Damage" },
                { amount: 3, info: "+1 Projectile" },
                { lifespan: 3.5, info: "+1.0s Duration" },
                { damage: 28, info: "+10 Damage" }
            ]
        },
        Garlic: {
            name: "Bawang Wibu",
            type: 'aura',
            auraSprite: 'assets/sprites/effects/garlic_aura.png',
            levels: [
                { cooldown: 1, damage: 5, area: 150, info: "Damages nearby enemies." },
                { area: 200, info: "+25% Area" },
                { damage: 8, info: "+3 Damage" },
                { cooldown: 0.8, info: "-20% Cooldown" },
                { area: 250, info: "+25% Area" },
                { damage: 12, info: "+4 Damage" },
            ]
        },
        HolyWater: {
            name: "Air Suci Kyiai",
            type: 'area',
            areaData: { duration: 3, size: 160, dps: 10 },
            levels: [
                { cooldown: 3, amount: 1, info: "Tosses a bottle creating a damaging zone." },
                { duration: 4, info: "+1s Duration" },
                { dps: 15, info: "+5 Damage/sec" },
                { amount: 2, info: "+1 Projectile" },
                { size: 100, info: "+20% Area" },
                { cooldown: 2.5, info: "-0.5s Cooldown" },
            ]
        },
        SpinningBook: {
            name: "Buku Memutar",
            type: 'orbit',
            orbitSprite: 'assets/sprites/weapons/spinning_book.png',
            levels: [
                { cooldown: 0, damage: 15, amount: 1, orbitSpeed: 2, orbitRadius: 100, info: "A book orbits you." },
                { amount: 2, info: "+1 Book" },
                { damage: 20, info: "+5 Damage" },
                { orbitRadius: 80, info: "Orbits closer" },
                { amount: 3, info: "+1 Book" },
                { orbitSpeed: 3, info: "+50% orbit speed" },
            ]
        }
    };
    
    // Passive Upgrades
    const PASSIVES = {
        Health: {
            name: "Batas Nyawa Tambah agak Dikit",
            levels: [
                { value: 1.1, info: "+10% Max Health" }, { value: 1.2, info: "+10% Max Health" },
                { value: 1.3, info: "+10% Max Health" }, { value: 1.4, info: "+10% Max Health" }
            ]
        },
        Speed: {
            name: "Gerak Cepat",
            levels: [
                { value: 1.1, info: "+10% Move Speed" }, { value: 1.2, info: "+10% Move Speed" },
                { value: 1.3, info: "+10% Move Speed" }, { value: 1.4, info: "+10% Move Speed" }
            ]
        },
        Magnet: {
            name: "Jarak Ngambil Exp",
            levels: [
                { value: 1.25, info: "+25% Pickup Radius" }, { value: 1.5, info: "+25% Pickup Radius" },
                { value: 1.75, info: "+25% Pickup Radius" }, { value: 2.0, info: "+25% Pickup Radius" }
            ]
        },
        Cooldown: {
            name: "Cooldown",
            levels: [
                { value: 0.9, info: "-10% Cooldown" }, { value: 0.8, info: "-10% Cooldown" },
                { value: 0.7, info: "-10% Cooldown" }, { value: 0.6, info: "-10% Cooldown" }
            ]
        },
        Damage: {
            name: "Menambah Damage Semua Weapon",
            levels: [
                { value: 1.1, info: "+10% Damage" }, { value: 1.2, info: "+10% Damage" },
                { value: 1.3, info: "+10% Damage" }, { value: 1.4, info: "+10% Damage" }
            ]
        },
    };

    // Decorative props (PNG templates)
    const PROP_TEMPLATES = [
        { name: 'Tree',  src: 'assets/props/tree.png',  width: 96, height: 128 },
        { name: 'Rock',  src: 'assets/props/rock.png',  width: 72, height: 56 },
        { name: 'Torch', src: 'assets/props/torch.png', width: 32, height: 64 },
        { name: 'Bush',  src: 'assets/props/bush.png',  width: 64, height: 48 },
    ];

    // Enemies
    const ENEMIES = {
        Bat: {
            name: 'Bat',
            health: 10, speed: 100, damage: 5, size: 40,
            xp: 2, spriteColor: '#8e44ad', sprite: 'assets/sprites/enemies/Bat.png',
            animations: { walk: { src: 'assets/sprites/enemies/Bat_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 10 } },
            lore: 'Hasil eksperimen gagal dari sebuah perusahaan bioteknologi yang mencoba menciptakan drone pengintai organik (bio-drone). Mereka mengganti sistem sonar kelelawar dengan satu lensa optik canggih yang menyatu dengan otak.',
            count: 0
        },
        Skeleton: {
            name: 'Skeleton',
            health: 30, speed: 60, damage: 10, size: 50,
            xp: 5, spriteColor: '#bdc3c7', sprite: 'assets/sprites/enemies/Skeleton.png',
            animations: { walk: { src: 'assets/sprites/enemies/Skeleton_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 8 } },
            lore: 'Bukanlah satu kerangka biasa, melainkan sisa-sisa dari Royal Scribe (Penulis Kerajaan) kuno yang terobsesi dengan pencatatan sejarah. Semasa hidup, ia takut akan kematian karena itu berarti ia berhenti mencatat. Melalui ritual terlarang, ia mengikat jiwanya pada tulang-belulangnya sendiri.',
            count: 0
        },
        Goblin: {
            name: 'Goblin',
            health: 20, speed: 150, damage: 8, size: 36,
            xp: 3, spriteColor: '#16a085', sprite: 'assets/sprites/enemies/Goblin.png',
            animations: { walk: { src: 'assets/sprites/enemies/Goblin_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 10 } },
            lore: 'The Scraptooth adalah kasta terendah dari suku Goblin yang dibuang ke lapisan dungeon/hutan yang lebih dalam karena terlalu tamak, bahkan bagi standar Goblin. Mereka tidak tertarik pada emas murni, melainkan terobsesi pada logam berkilau yang menempel pada tubuh manusia (gesper sabuk, pelindung lutut, kancing baju zirah).',
            count: 0
        },
        Boss: {
            name: 'Boss',
            health: 500, speed: 40, damage: 25, size: 100,
            xp: 100, spriteColor: '#c0392b', sprite: 'assets/sprites/enemies/Boss.png',
            animations: { walk: { src: 'assets/sprites/enemies/Boss_walk.png', frameWidth: 64, frameHeight: 64, frames: 4, fps: 10 } },
            lore: 'Dulunya adalah seorang pesulap jalanan yang sangat berbakat namun miskin. Ia terobsesi dengan trik "menghilang" yang sempurna. Dalam keputusasaannya mencari ketenaran, ia membuat perjanjian dengan entitas kegelapan untuk mendapatkan kemampuan menjadi bayangan sejati.',
            count: 0
        }
    };
    
    // Enemy spawn waves configuration
    const SPAWN_WAVES = [
        { time: 0, enemy: 'Bat', count: 10, interval: 2 },
        { time: 30, enemy: 'Skeleton', count: 5, interval: 3 },
        { time: 60, enemy: 'Bat', count: 20, interval: 1 },
        { time: 120, enemy: 'Goblin', count: 15, interval: 1.5 },
        { time: 300, enemy: 'Skeleton', count: 15, interval: 2 },
        { time: 600, enemy: 'Boss', count: 1, interval: 0 },
        { time: 630, enemy: 'Bat', count: 50, interval: 0.5 },
        { time: 900, enemy: 'Goblin', count: 30, interval: 1 },
        { time: 1200, enemy: 'Boss', count: 2, interval: 10 },
        { time: 1500, enemy: 'Bat', count: 100, interval: 0.2 },
        { time: 1700, enemy: 'Skeleton', count: 40, interval: 1 },
        { time: 1800, enemy: 'Boss', count: 3, interval: 5 },
    ];


    // --- GAME OBJECT CLASSES ---

    class GameObject {
        constructor(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.active = true;
        }
        
        get BBox() {
            return {
                left: this.x - this.width / 2,
                right: this.x + this.width / 2,
                top: this.y - this.height / 2,
                bottom: this.y + this.height / 2
            };
        }
    }

    class Player extends GameObject {
        constructor(x, y, characterData) {
            super(x, y, 60, 60);
            this.charData = characterData;
            this.baseStats = { ...characterData.stats };
            this.passives = {};
            this.weapons = [];
            this.level = 1;
            this.xp = 0;
            this.xpToNextLevel = CONFIG.XP_TO_LEVEL;
            this.health = this.maxHealth;
            this.spriteColor = characterData.spriteColor;
            this.invincible = false;
            this.invincibleTimer = 0;
            this.facing = 1; // 1 = right, -1 = left
            this.moving = false;
            this.animFrame = 0;
            this.animTimer = 0;
        }

        // Apply passive buffs to base stats
        get speed() { return this.baseStats.speed * (this.passives.Speed?.value || 1); }
        get maxHealth() { return this.baseStats.maxHealth * (this.passives.Health?.value || 1); }
        get magnet() { return CONFIG.MAGNET_RADIUS * this.baseStats.magnet * (this.passives.Magnet?.value || 1); }
        get luck() { return this.baseStats.luck * (this.passives.Luck?.value || 1); }
        get cooldownModifier() { return this.passives.Cooldown?.value || 1; }
        get damageModifier() { return this.passives.Damage?.value || 1; }

        addWeapon(weaponName) {
            if (this.weapons.some(w => w.name === weaponName)) return;
            const newWeapon = new Weapon(weaponName, this);
            this.weapons.push(newWeapon);
        }

        addPassive(passiveName) {
            const level = this.passives[passiveName] ? this.passives[passiveName].level + 1 : 1;
            const passiveData = PASSIVES[passiveName];
            if (level > passiveData.levels.length) return;
            
            this.passives[passiveName] = {
                level: level,
                ...passiveData.levels[level - 1]
            };
            
            if (passiveName === 'Health') {
                this.health = this.maxHealth; // Heal to full on health upgrade
            }
        }

        update(dt, keys) {
            let dx = 0;
            let dy = 0;
            if (keys['w'] || keys['ArrowUp']) dy -= 1;
            if (keys['s'] || keys['ArrowDown']) dy += 1;
            if (keys['a'] || keys['ArrowLeft']) dx -= 1;
            if (keys['d'] || keys['ArrowRight']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                this.x += (dx / magnitude) * this.speed * dt;
                this.y += (dy / magnitude) * this.speed * dt;
            }
            this.moving = (dx !== 0 || dy !== 0);

            if (this.charData && this.charData.animations && this.charData.animations.walk) {
                const cfg = this.charData.animations.walk;
                const fps = cfg.fps || 8;
                if (this.moving) {
                    this.animTimer += dt;
                    const frameTime = 1 / fps;
                    while (this.animTimer >= frameTime) {
                        this.animTimer -= frameTime;
                        this.animFrame = (this.animFrame + 1) % (cfg.frames || 1);
                    }
                } else {
                    this.animFrame = 0;
                    this.animTimer = 0;
                }
            }
            
            // Invincibility frames
            if (this.invincible) {
                this.invincibleTimer -= dt;
                if (this.invincibleTimer <= 0) {
                    this.invincible = false;
                }
            }

            this.weapons.forEach(w => w.update(dt));
        }
        
        takeDamage(amount) {
            if (this.invincible) return;
            this.health -= amount;
            this.invincible = true;
            this.invincibleTimer = 0.5; // 0.5s of invincibility
            if (this.health <= 0) {
                this.health = 0;
                game.gameOver();
            }
        }

        gainXP(amount) {
            this.xp += amount;
            if (this.xp >= this.xpToNextLevel) {
                this.levelUp();
            }
        }

        levelUp() {
            this.xp -= this.xpToNextLevel;
            this.level++;
            this.xpToNextLevel = Math.floor(this.xpToNextLevel * CONFIG.XP_GROWTH);
            this.health = this.maxHealth; // Heal on level up
            game.state = 'level-up';
        }

        draw(ctx, camera) {
            const px = this.x - this.width / 2 - camera.x;
            const py = this.y - this.height / 2 - camera.y;
            const flicker = this.invincible && Math.floor(this.invincibleTimer * 10) % 2 === 0;
            const cfg = this.charData && this.charData.animations && this.charData.animations.walk;
            if (cfg && cfg.src) {
                if (!this.animImg) {
                    this.animImg = new Image();
                    this.animReady = false;
                    this.animImg.onload = () => { this.animReady = true; };
                    this.animImg.src = cfg.src;
                }
                if (this.animImg && this.animReady) {
                    const fw = cfg.frameWidth || this.width;
                    const fh = cfg.frameHeight || this.height;
                    const frames = cfg.frames || 1;
                    const frameIndex = Math.min(this.animFrame || 0, frames - 1);
                    const sx = (frameIndex % frames) * fw;
                    const sy = 0;
                    ctx.save();
                    ctx.translate(px + this.width / 2, py + this.height / 2);
                    ctx.scale(this.facing, 1);
                    if (flicker) ctx.globalAlpha = 0.6;
                    ctx.drawImage(this.animImg, sx, sy, fw, fh, -this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.restore();
                } else {
                    if (!this.spriteImg && this.charData && this.charData.sprite) {
                        this.spriteImg = new Image();
                        this.spriteReady = false;
                        this.spriteImg.onload = () => { this.spriteReady = true; };
                        this.spriteImg.src = this.charData.sprite;
                    }
                    if (this.spriteImg && this.spriteReady) {
                        if (flicker) {
                            ctx.save();
                            ctx.globalAlpha = 0.5;
                            ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
                            ctx.restore();
                        } else {
                            ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
                        }
                    } else {
                        ctx.fillStyle = flicker ? 'white' : this.spriteColor;
                        ctx.fillRect(px, py, this.width, this.height);
                    }
                }
            } else {
                if (!this.spriteImg && this.charData && this.charData.sprite) {
                    this.spriteImg = new Image();
                    this.spriteReady = false;
                    this.spriteImg.onload = () => { this.spriteReady = true; };
                    this.spriteImg.src = this.charData.sprite;
                }
                if (this.spriteImg && this.spriteReady) {
                    if (flicker) {
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
                        ctx.restore();
                    } else {
                        ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
                    }
                } else {
                    ctx.fillStyle = flicker ? 'white' : this.spriteColor;
                    ctx.fillRect(px, py, this.width, this.height);
                }
            }
        }
    }
    
    class Enemy extends GameObject {
        constructor(x, y, type) {
            super(x, y, type.size, type.size);
            this.type = type;
            this.health = type.health;
            this.speed = type.speed;
            this.damage = type.damage;
            this.xp = type.xp;
            this.spriteColor = type.spriteColor;
            this.facing = 1;
            this.moving = false;
            this.animFrame = 0;
            this.animTimer = 0;
        }

        update(dt, player) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0) {
                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
                if (dx !== 0) this.facing = dx > 0 ? 1 : -1;
            }
            this.moving = dist > 1;

            if (this.type && this.type.animations && this.type.animations.walk) {
                const cfg = this.type.animations.walk;
                const fps = cfg.fps || 8;
                if (this.moving) {
                    this.animTimer += dt;
                    const frameTime = 1 / fps;
                    while (this.animTimer >= frameTime) {
                        this.animTimer -= frameTime;
                        this.animFrame = (this.animFrame + 1) % (cfg.frames || 1);
                    }
                } else {
                    this.animFrame = 0;
                    this.animTimer = 0;
                }
            }
        }
        
        takeDamage(amount, knockbackDir) {
            this.health -= amount;
            if(knockbackDir && knockbackDir.x && knockbackDir.y) {
                 this.x += knockbackDir.x;
                 this.y += knockbackDir.y;
            }
            if (this.health <= 0) {
                this.active = false;
                game.enemyKilled(this);
            }
        }

        draw(ctx, camera) {
            const px = this.x - this.width / 2 - camera.x;
            const py = this.y - this.height / 2 - camera.y;
            const cfg = this.type && this.type.animations && this.type.animations.walk;
            if (cfg && cfg.src) {
                if (!this.animImg) {
                    this.animImg = new Image();
                    this.animReady = false;
                    this.animImg.onload = () => { this.animReady = true; };
                    this.animImg.src = cfg.src;
                }
                if (this.animImg && this.animReady) {
                    const fw = cfg.frameWidth || this.width;
                    const fh = cfg.frameHeight || this.height;
                    const frames = cfg.frames || 1;
                    const frameIndex = Math.min(this.animFrame || 0, frames - 1);
                    const sx = (frameIndex % frames) * fw;
                    const sy = 0;
                    ctx.save();
                    ctx.translate(px + this.width / 2, py + this.height / 2);
                    ctx.scale(this.facing, 1);
                    ctx.drawImage(this.animImg, sx, sy, fw, fh, -this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.restore();
                    return;
                }
            }

            if (!this.spriteImg && this.type && this.type.sprite) {
                this.spriteImg = new Image();
                this.spriteReady = false;
                this.spriteImg.onload = () => { this.spriteReady = true; };
                this.spriteImg.src = this.type.sprite;
            }
            if (this.spriteImg && this.spriteReady) {
                ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
            } else {
                ctx.fillStyle = this.spriteColor;
                ctx.fillRect(px, py, this.width, this.height);
            }
        }
    }

    class ExperienceGem extends GameObject {
        constructor(x, y, value) {
            super(x, y, 20, 20);
            this.value = value;
            this.speed = 300;
        }
        
        update(dt, player) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < player.magnet) {
                if (dist < 20) { // Close enough to collect (scaled for larger gem)
                    this.active = false;
                    player.gainXP(this.value);
                } else {
                    this.x += (dx / dist) * this.speed * dt;
                    this.y += (dy / dist) * this.speed * dt;
                }
            }
        }

        draw(ctx, camera) {
            const px = this.x - this.width / 2 - camera.x;
            const py = this.y - this.height / 2 - camera.y;
            if (!this.spriteImg) {
                this.spriteImg = new Image();
                this.spriteReady = false;
                this.spriteImg.onload = () => { this.spriteReady = true; };
                this.spriteImg.src = 'assets/sprites/items/experience_gem.png';
            }
            if (this.spriteImg && this.spriteReady) {
                ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
            } else {
                const hx = this.width / 2;
                const hy = this.height / 2;
                ctx.fillStyle = 'cyan';
                ctx.beginPath();
                ctx.moveTo(this.x - camera.x, this.y - hy - camera.y);
                ctx.lineTo(this.x + hx - camera.x, this.y - camera.y);
                ctx.lineTo(this.x - camera.x, this.y + hy - camera.y);
                ctx.lineTo(this.x - hx - camera.x, this.y - camera.y);
                ctx.closePath();
                ctx.fill();
            }
        }
    }
    
    // --- CHEST AND FOOD ITEMS ---
    class ChestBox extends GameObject {
        constructor(x, y) {
            super(x, y, 60, 60);
            this.opened = false;
        }
        get spritePath() { return 'assets/sprites/items/chest.png'; }
        open() {
            if (this.opened || !this.active) return;
            this.opened = true;
            this.active = false;
            if (typeof game?.spawnFood === 'function') {
                game.spawnFood(this.x, this.y);
            }
            if (typeof game?.createParticles === 'function') {
                game.createParticles(this.x, this.y, 'gold', 12);
            }
        }
        draw(ctx, camera) {
            const px = this.x - this.width / 2 - camera.x;
            const py = this.y - this.height / 2 - camera.y;
            if (!this.spriteImg) {
                this.spriteImg = new Image();
                this.spriteReady = false;
                this.spriteImg.onload = () => { this.spriteReady = true; };
                this.spriteImg.src = this.spritePath;
            }
            if (this.spriteImg && this.spriteReady) {
                ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
            } else {
                ctx.fillStyle = '#8b5a2b'; // brown chest
                ctx.fillRect(px, py, this.width, this.height);
                ctx.fillStyle = '#d4af37'; // golden band
                ctx.fillRect(px, py + this.height/2 - 6, this.width, 12);
            }
        }
    }

    class FoodItem extends GameObject {
        constructor(x, y) {
            super(x, y, 30, 30);
        }
        get spritePath() { return 'assets/sprites/items/food.png'; }
        draw(ctx, camera) {
            const px = this.x - this.width / 2 - camera.x;
            const py = this.y - this.height / 2 - camera.y;
            if (!this.spriteImg) {
                this.spriteImg = new Image();
                this.spriteReady = false;
                this.spriteImg.onload = () => { this.spriteReady = true; };
                this.spriteImg.src = this.spritePath;
            }
            if (this.spriteImg && this.spriteReady) {
                ctx.drawImage(this.spriteImg, px, py, this.width, this.height);
            } else {
                ctx.fillStyle = 'limegreen';
                ctx.fillRect(px, py, this.width, this.height);
            }
        }
    }

    // Decorative world prop (static)
    class Prop extends GameObject {
        constructor(x, y, tpl) {
            super(x, y, tpl.width, tpl.height);
            this.src = tpl.src;
            this.img = null; this.ready = false;
        }
        draw(ctx, camera) {
            const px = this.x - this.width / 2 - camera.x;
            const py = this.y - this.height / 2 - camera.y;
            if (!this.img && this.src) {
                this.img = new Image();
                this.img.onload = () => { this.ready = true; };
                this.img.src = this.src;
            }
            if (this.img && this.ready) {
                ctx.drawImage(this.img, px, py, this.width, this.height);
            } else {
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(px, py, this.width, this.height);
                ctx.strokeStyle = '#34495e';
                ctx.strokeRect(px, py, this.width, this.height);
            }
        }
    }

    class Projectile extends GameObject {
        constructor(x, y, target, weaponStats) {
            super(x, y, weaponStats.size, weaponStats.size);
            this.stats = weaponStats;
            this.lifespan = weaponStats.lifespan;
            this.pierce = weaponStats.pierce;
            this.hitEnemies = [];
            
            if(this.stats.arc) {
                this.vx = (Math.random() - 0.5) * weaponStats.speed * 1.5;
                this.vy = -weaponStats.speed * (1 + Math.random() * 0.5);
                this.gravity = 500;
            } else {
                 const dx = target.x - x;
                 const dy = target.y - y;
                 const dist = Math.sqrt(dx * dx + dy * dy);
                 this.vx = (dx / dist) * weaponStats.speed;
                 this.vy = (dy / dist) * weaponStats.speed;
            }
        }
        
        update(dt) {
            if(this.stats.arc) {
                this.vy += this.gravity * dt;
            }
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            // Bounce off screen edges (relative to camera viewport)
            if (this.stats.bounce && typeof game !== 'undefined' && game.canvas && game.camera) {
                const hx = this.width / 2, hy = this.height / 2;
                const left = game.camera.x, right = game.camera.x + game.canvas.width;
                const top = game.camera.y, bottom = game.camera.y + game.canvas.height;
                if (this.x - hx < left) { this.x = left + hx; this.vx = Math.abs(this.vx); }
                else if (this.x + hx > right) { this.x = right - hx; this.vx = -Math.abs(this.vx); }
                if (this.y - hy < top) { this.y = top + hy; this.vy = Math.abs(this.vy); }
                else if (this.y + hy > bottom) { this.y = bottom - hy; this.vy = -Math.abs(this.vy); }
            }
            this.lifespan -= dt;
            if (this.lifespan <= 0) this.active = false;
        }
        
        onHit(enemy) {
            if(this.hitEnemies.includes(enemy)) return;
            
            this.hitEnemies.push(enemy);
            this.pierce--;
            if (this.pierce < 0) this.active = false;
        }
        
        draw(ctx, camera) {
            const cx = this.x - camera.x;
            const cy = this.y - camera.y;
            if (!this.spriteImg && this.stats && this.stats.sprite) {
                this.spriteImg = new Image();
                this.spriteReady = false;
                this.spriteImg.onload = () => { this.spriteReady = true; };
                this.spriteImg.src = this.stats.sprite;
            }
            if (this.spriteImg && this.spriteReady) {
                const angle = Math.atan2(this.vy, this.vx) || 0;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                ctx.drawImage(this.spriteImg, -this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();
            } else {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(cx, cy, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    class DamageArea extends GameObject {
        constructor(x, y, stats) {
            super(x, y, stats.size, stats.size);
            this.stats = stats;
            this.duration = stats.duration;
            this.dps = stats.dps;
            this.damageInterval = 0.5; // Damage every 0.5s
            this.damageTimer = 0;
            this.hitEnemies = new Set();
        }
        
        update(dt) {
            this.duration -= dt;
            if(this.duration <= 0) this.active = false;
            
            this.damageTimer -= dt;
            if(this.damageTimer <= 0) {
                this.damageTimer = this.damageInterval;
                this.hitEnemies.clear(); // Reset hit enemies for this damage tick
            }
        }
        
        draw(ctx, camera) {
            ctx.fillStyle = 'rgba(100, 100, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(this.x - camera.x, this.y - camera.y, this.width / 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // --- WEAPON SYSTEM ---
    
    class Weapon {
        constructor(name, player) {
            this.name = name;
            this.player = player;
            this.data = WEAPONS[name];
            this.level = 0;
            this.lastFired = 0;
            this.orbitAngle = Math.random() * Math.PI * 2;
            this.attackEffects = [];
            this.levelUp();
        }
        
        getStats() {
            const stats = {};
            // Combine stats from all levels up to current
            for (let i = 0; i <= this.level -1; i++) {
                Object.assign(stats, this.data.levels[i]);
            }
            // Apply global modifiers
            if (stats.cooldown != null) stats.cooldown *= this.player.cooldownModifier;
            if (stats.damage != null) stats.damage *= this.player.damageModifier;
            if (stats.dps != null) stats.dps *= this.player.damageModifier;
            return stats;
        }

        levelUp() {
            if (this.level >= this.data.levels.length) return;
            this.level++;
        }
        
        update(dt) {
            this.lastFired += dt;
            const stats = this.getStats();
            
            if (stats.cooldown > 0 && this.lastFired >= stats.cooldown) {
                this.fire(stats);
                this.lastFired = 0;
            }
            
            if (this.data.type === 'orbit') {
                this.orbitAngle += (stats.orbitSpeed || 1) * dt;
            }

            // Update temporary melee effects (e.g., whip swings)
            if (this.attackEffects && this.attackEffects.length) {
                this.attackEffects.forEach(e => e.t -= dt);
                this.attackEffects = this.attackEffects.filter(e => e.t > 0);
            }
        }
        
        fire(stats) {
            const nearestEnemy = game.findNearestEnemy(this.player.x, this.player.y);
            
            switch(this.data.type) {
                case 'attack': { // Whip
                    const baseDir = this.player.facing || 1;
                    const dirs = (stats.amount >= 2) ? [baseDir, -baseDir] : [baseDir];
                    dirs.forEach(dir => {
                        const attackArea = {
                            x: this.player.x + (dir * 150 * (stats.area || 1)),
                            y: this.player.y,
                            width: 300 * (stats.area || 1),
                            height: 60
                        };
                        game.checkAttackCollision(attackArea, stats.damage);
                        // Add visual whip effect
                        this.attackEffects.push({
                            x: attackArea.x,
                            y: attackArea.y,
                            w: attackArea.width,
                            h: attackArea.height,
                            dir: dir,
                            t: 0.12
                        });
                    });
                    break;
                }
                case 'projectile': { // Magic Wand, Axe
                    if (!nearestEnemy) return;
                    for(let i=0; i<stats.amount; i++) {
                        const projStats = { ...this.data.projectile, ...stats };
                        game.addProjectile(new Projectile(this.player.x, this.player.y, nearestEnemy, projStats));
                    }
                    break;
                }
                case 'area': { // Holy Water
                      if (!nearestEnemy) return;
                      for(let i=0; i<stats.amount; i++) {
                        const targetX = nearestEnemy.x + rand(-50, 50);
                        const targetY = nearestEnemy.y + rand(-50, 50);
                        const areaStats = { ...this.data.areaData };
                        if (stats.duration != null) areaStats.duration = stats.duration;
                        if (stats.size != null) areaStats.size = stats.size;
                        if (stats.dps != null) areaStats.dps = stats.dps;
                        game.addDamageArea(new DamageArea(targetX, targetY, areaStats));
                    }
                    break;
                }
                // Aura and Orbit are handled via collision checks in Game class, not firing events
            }
        }
        
        // Used for rendering auras/orbiting items
        draw(ctx, camera) {
             const stats = this.getStats();
             switch(this.data.type) {
                 case 'attack': // Whip
                    if (!this.swordImg && this.data.attackSprite) {
                        this.swordImg = new Image();
                        this.swordReady = false;
                        this.swordImg.onload = () => { this.swordReady = true; };
                        this.swordImg.src = this.data.attackSprite;
                    }
                    if (this.attackEffects && this.attackEffects.length) {
                        this.attackEffects.forEach(e => {
                            const cx = e.x - camera.x;
                            const cy = e.y - camera.y;
                            ctx.save();
                            ctx.translate(cx, cy);
                            ctx.scale(e.dir, 1);
                            if (this.swordImg && this.swordReady) {
                                ctx.globalAlpha = Math.max(0, Math.min(1, e.t / 0.12));
                                ctx.drawImage(this.swordImg, -e.w / 2, -e.h / 2, e.w, e.h);
                            } else {
                                ctx.globalAlpha = 0.3;
                                ctx.fillStyle = 'white';
                                ctx.fillRect(-e.w / 2, -e.h / 2, e.w, e.h);
                            }
                            ctx.restore();
                        });
                        ctx.globalAlpha = 1;
                    }
                    break;
                 case 'aura': // Garlic
                    if (!this.auraImg && this.data.auraSprite) {
                        this.auraImg = new Image();
                        this.auraReady = false;
                        this.auraImg.onload = () => { this.auraReady = true; };
                        this.auraImg.src = this.data.auraSprite;
                    }
                    if (this.auraImg && this.auraReady) {
                        const r = stats.area;
                        const size = r * 2;
                        ctx.drawImage(this.auraImg, this.player.x - r - camera.x, this.player.y - r - camera.y, size, size);
                    } else {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.beginPath();
                        ctx.arc(this.player.x - camera.x, this.player.y - camera.y, stats.area, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    break;
                 case 'orbit': // Spinning Book
                    for (let i = 0; i < stats.amount; i++) {
                        const angle = this.orbitAngle + (i * (2 * Math.PI / stats.amount));
                        const x = this.player.x + Math.cos(angle) * stats.orbitRadius;
                        const y = this.player.y + Math.sin(angle) * stats.orbitRadius;
                        if (!this.orbitImg && this.data.orbitSprite) {
                            this.orbitImg = new Image();
                            this.orbitReady = false;
                            this.orbitImg.onload = () => { this.orbitReady = true; };
                            this.orbitImg.src = this.data.orbitSprite;
                        }
                        if (this.orbitImg && this.orbitReady) {
                            ctx.drawImage(this.orbitImg, x - 20 - camera.x, y - 30 - camera.y, 40, 60);
                        } else {
                            ctx.fillStyle = 'saddlebrown';
                            ctx.fillRect(x - 20 - camera.x, y - 30 - camera.y, 40, 60);
                        }
                    }
                    break;
             }
        }
    }


    // --- MAIN GAME CLASS ---

    class Game {
        constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.keys = {};
            this.state = 'main-menu'; // main-menu, character-selection, playing, paused, level-up, game-over
            this.lastTime = 0;
            this.accumulator = 0;
            this.deltaTime = 1 / 60; // Fixed timestep for physics
            
            this.camera = { x: 0, y: 0 };
            
            // Game Objects
            this.player = null;
            this.enemies = [];
            this.projectiles = [];
            this.xpGems = [];
            this.damageAreas = [];
            this.particles = [];
            this.chests = [];
            this.foods = [];
            this.props = [];
            this.props = [];
            this.backgroundLayers = [
                { src: 'assets/backgrounds/ground.png',         img: null, ready: false, tileSize: 128, parallax: 1.0 }
            ];
            
            // Timers & Stats
            this.gameTimer = 0;
            this.spawnTimer = 0;
            this.totalKills = 0;
            this.chestTimer = 0;
            this.debug = { charHitbox: false, weaponHitbox: false };
            this.hitboxImg = null; this.hitboxReady = false;
            
            this.initUI();
            this.initInput();
        }

        init() {
            // Reset game state for a new game
            this.enemies = [];
            this.projectiles = [];
            this.xpGems = [];
            this.damageAreas = [];
            this.particles = [];
            this.chests = [];
            this.foods = [];
            
            this.gameTimer = 0;
            this.spawnTimer = 0;
            this.totalKills = 0;
            this.chestTimer = 0;
            
            // Reset enemy counts
            Object.values(ENEMIES).forEach(e => e.count = 0);
            
            // FIX: Reset spawn wave timers
            SPAWN_WAVES.forEach(wave => delete wave.lastSpawn);
            // Generate decorative props
            if (typeof this.initProps === 'function') this.initProps();
        }
        
        startGame(characterData) {
            this.init();
            this.player = new Player(this.canvas.width / 2, this.canvas.height / 2, characterData);
            this.player.addWeapon(characterData.startingWeapon);
            this.state = 'playing';
            this.showScreen('none');
            this.lastTime = performance.now();
            this.gameLoop();
        }
        
        gameOver() {
            this.state = 'game-over';
            this.updateGameOverUI();
            this.showScreen('game-over-screen');
        }

        // --- Game Loop ---
        gameLoop(currentTime = 0) {
            if (this.state === 'quit') {
                this.state = 'main-menu';
                this.showScreen('main-menu');
                return;
            }
            
            const frameTime = (currentTime - this.lastTime) / 1000;
            this.lastTime = currentTime;
            this.accumulator += frameTime;

            while (this.accumulator >= this.deltaTime) {
                if(this.state === 'playing') {
                    this.update(this.deltaTime);
                }
                this.accumulator -= this.deltaTime;
            }
            
            this.draw();

            requestAnimationFrame(this.gameLoop.bind(this));
        }

        // --- Update Logic ---
        update(dt) {
            this.gameTimer += dt;
            
            // Player Update
            this.player.update(dt, this.keys);
            
            // Enemy Spawning
            this.updateSpawning(dt);

            // Chest Spawning
            this.chestTimer += dt;
            if (this.chestTimer >= (CONFIG.CHEST_SPAWN_INTERVAL || 25)) {
                if ((this.chests?.length || 0) < (CONFIG.CHEST_MAX_ON_FIELD || 3)) {
                    this.spawnChest();
                }
                this.chestTimer = 0;
            }

            // Update Game Objects
            this.enemies.forEach(e => e.update(dt, this.player));
            this.projectiles.forEach(p => p.update(dt));
            this.xpGems.forEach(gem => gem.update(dt, this.player));
            this.damageAreas.forEach(area => area.update(dt));
            this.particles.forEach(p => p.update(dt));
            this.foods.forEach(f => f.update?.(dt, this.player));

            // Collisions
            this.handleCollisions();
            
            // Cleanup inactive objects
            this.cleanupObjects();

            // Update Camera
            this.camera.x = this.player.x - this.canvas.width / 2;
            this.camera.y = this.player.y - this.canvas.height / 2;
            
            // Win condition
            if(this.gameTimer >= CONFIG.GAME_DURATION / 1000) {
                this.gameOver(); // Player survived!
            }
        }
        
        updateSpawning(dt) {
             this.spawnTimer += dt;
             SPAWN_WAVES.forEach(wave => {
                 if (this.gameTimer >= wave.time && (!wave.lastSpawn || this.spawnTimer - wave.lastSpawn > wave.interval)) {
                      for(let i=0; i<wave.count; i++) {
                        this.spawnEnemy(wave.enemy);
                      }
                      wave.lastSpawn = this.spawnTimer;
                 }
             });
        }
        
        spawnEnemy(enemyType) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(this.canvas.width, this.canvas.height) * 0.75;
            const x = this.player.x + Math.cos(angle) * radius;
            const y = this.player.y + Math.sin(angle) * radius;
            const enemyData = ENEMIES[enemyType];
            
            // Limit total enemies of a type on screen
            if(enemyData.count >= (enemyType === 'Boss' ? 5 : 100)) return;
            
            this.enemies.push(new Enemy(x, y, enemyData));
            enemyData.count++;
        }
        
        // --- Collision Handling ---
        
        checkCollision(obj1, obj2) {
            const box1 = obj1.BBox;
            const box2 = obj2.BBox;
            return box1.left < box2.right && box1.right > box2.left &&
                   box1.top < box2.bottom && box1.bottom > box2.top;
        }
        
        handleCollisions() {
            // Player vs Enemies
            this.enemies.forEach(enemy => {
                if (this.checkCollision(this.player, enemy)) {
                    this.player.takeDamage(enemy.damage);
                }
            });
            
            // Projectiles vs Enemies
            this.projectiles.forEach(proj => {
                this.enemies.forEach(enemy => {
                    if (proj.active && enemy.active && this.checkCollision(proj, enemy)) {
                        enemy.takeDamage(proj.stats.damage);
                        proj.onHit(enemy);
                    }
                });
            });

            // Projectiles vs Chests
            this.projectiles.forEach(proj => {
                this.chests.forEach(chest => {
                    if (proj.active && chest.active && this.checkCollision(proj, chest)) {
                        chest.open();
                        proj.onHit({});
                    }
                });
            });
            
            // Aura/Orbit weapons vs Enemies
            const activeWeapons = this.player.weapons;
            activeWeapons.forEach(weapon => {
                const stats = weapon.getStats();
                if (weapon.data.type === 'aura') {
                    const auraRadius = stats.area;
                    this.enemies.forEach(enemy => {
                          if(enemy.active) {
                            const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                            if(dist < auraRadius + enemy.width / 2) {
                                // Simple time-based damage application to avoid instant death
                                if(!enemy.lastAuraHit || this.gameTimer - enemy.lastAuraHit > 1/stats.cooldown) {
                                    const knockbackDir = {
                                        x: (enemy.x - this.player.x) / dist * (stats.knockback || 1),
                                        y: (enemy.y - this.player.y) / dist * (stats.knockback || 1)
                                    };
                                    enemy.takeDamage(stats.damage, knockbackDir);
                                    enemy.lastAuraHit = this.gameTimer;
                                }
                            }
                         }
                    });
                    // Aura can open chests too
                    this.chests.forEach(chest => {
                        if (chest.active) {
                            const dist = Math.hypot(this.player.x - chest.x, this.player.y - chest.y);
                            if (dist < auraRadius + chest.width / 2) {
                                chest.open();
                            }
                        }
                    });
                } else if (weapon.data.type === 'orbit') {
                     for (let i = 0; i < stats.amount; i++) {
                        const angle = weapon.orbitAngle + (i * (2 * Math.PI / stats.amount));
                        const bookX = this.player.x + Math.cos(angle) * stats.orbitRadius;
                        const bookY = this.player.y + Math.sin(angle) * stats.orbitRadius;
                        const book = { BBox: { left: bookX-20, right: bookX+20, top: bookY-30, bottom: bookY+30 }};
                        
                        this.enemies.forEach(enemy => {
                            if(enemy.active && this.checkCollision(book, enemy)) {
                                if(!enemy.lastOrbitHit || this.gameTimer - enemy.lastOrbitHit > 0.5) {
                                    enemy.takeDamage(stats.damage);
                                    enemy.lastOrbitHit = this.gameTimer;
                                }
                            }
                        });
                        this.chests.forEach(chest => {
                            if(chest.active && this.checkCollision(book, chest)) {
                                chest.open();
                            }
                        });
                     }
                }
            });

            // Damage Areas vs Enemies
            this.damageAreas.forEach(area => {
                this.enemies.forEach(enemy => {
                    if(area.active && enemy.active && !area.hitEnemies.has(enemy)) {
                        const dist = Math.hypot(area.x - enemy.x, area.y - enemy.y);
                        if (dist < area.width/2 + enemy.width/2) {
                            enemy.takeDamage(area.dps * area.damageInterval);
                            area.hitEnemies.add(enemy);
                        }
                    }
                });
                // Holy water areas also open chests
                this.chests.forEach(chest => {
                    if (area.active && chest.active) {
                        const dist = Math.hypot(area.x - chest.x, area.y - chest.y);
                        if (dist < area.width/2 + chest.width/2) {
                            chest.open();
                        }
                    }
                });
            });

            // Player vs Food (pickup)
            this.foods.forEach(food => {
                if (food.active && this.checkCollision(this.player, food)) {
                    const heal = this.player.maxHealth * 0.15;
                    this.player.health = Math.min(this.player.maxHealth, this.player.health + heal);
                    food.active = false;
                    this.createParticles(food.x, food.y, 'lime', 10);
                }
            });
        }
        
        // Whip collision check
        checkAttackCollision(area, damage) {
            const attackBox = { BBox: {
                left: area.x - area.width/2, right: area.x + area.width/2,
                top: area.y - area.height/2, bottom: area.y + area.height/2
            }};
            
            this.enemies.forEach(enemy => {
                if(enemy.active && this.checkCollision(attackBox, enemy)) {
                    // Avoid hitting same enemy multiple times with one swing
                     if(!enemy.lastHitBySword || this.gameTimer - enemy.lastHitBySword > 1) {
                         enemy.takeDamage(damage);
                         enemy.lastHitBySword = this.gameTimer;
                     }
                }
            });

            // Hit chests too
            this.chests.forEach(chest => {
                if(chest.active && this.checkCollision(attackBox, chest)) {
                    chest.open();
                }
            });
        }
        
        enemyKilled(enemy) {
            this.totalKills++;
            ENEMIES[enemy.type.name].count--;
            this.xpGems.push(new ExperienceGem(enemy.x, enemy.y, enemy.xp));
            this.createParticles(enemy.x, enemy.y, enemy.spriteColor, 10);
        }

        cleanupObjects() {
            this.enemies = this.enemies.filter(e => e.active);
            this.projectiles = this.projectiles.filter(p => p.active);
            this.xpGems = this.xpGems.filter(gem => gem.active);
            this.damageAreas = this.damageAreas.filter(area => area.active);
            this.particles = this.particles.filter(p => p.active);
            this.chests = this.chests.filter(c => c.active);
            this.foods = this.foods.filter(f => f.active);
        }
        
        drawBackground() {
            const ctx = this.ctx;
            const w = this.canvas.width;
            const h = this.canvas.height;
            let drew = false;
            if (this.backgroundLayers && this.backgroundLayers.length) {
                this.backgroundLayers.forEach(layer => {
                    if (!layer.src) return;
                    if (!layer.img) {
                        layer.img = new Image();
                        layer.ready = false;
                        layer.img.onload = () => { layer.ready = true; };
                        layer.img.src = layer.src;
                    }
                    if (!layer.ready) return;
                    const parallax = (layer.parallax === undefined) ? 1 : layer.parallax;
                    const tile = layer.tileSize || 64;
                    const viewLeft = this.camera.x * parallax;
                    const viewTop = this.camera.y * parallax;
                    const startX = Math.floor(viewLeft / tile) * tile;
                    const startY = Math.floor(viewTop / tile) * tile;
                    for (let x = startX; x < viewLeft + w + tile; x += tile) {
                        for (let y = startY; y < viewTop + h + tile; y += tile) {
                            const dx = Math.floor(x - viewLeft);
                            const dy = Math.floor(y - viewTop);
                            ctx.drawImage(layer.img, dx, dy, tile, tile);
                        }
                    }
                    drew = true;
                });
            }
            if (!drew) {
                ctx.fillStyle = '#1a2a1a';
                ctx.fillRect(0, 0, w, h);
            }
        }
        
        // --- Drawing ---
        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawBackground();
            if (!this.player || this.state === 'main-menu' || this.state === 'character-selection') return;
            
            // Draw game objects relative to camera
            this.drawProps();
            this.damageAreas.forEach(area => area.draw(this.ctx, this.camera));
            this.chests.forEach(c => c.draw(this.ctx, this.camera));
            this.foods.forEach(f => f.draw(this.ctx, this.camera));
            this.xpGems.forEach(gem => gem.draw(this.ctx, this.camera));
            this.enemies.forEach(e => e.draw(this.ctx, this.camera));
            this.projectiles.forEach(p => p.draw(this.ctx, this.camera));
            this.player.weapons.forEach(w => w.draw(this.ctx, this.camera));
            this.player.draw(this.ctx, this.camera);
            this.particles.forEach(p => p.draw(this.ctx, this.camera));
            
            this.drawHitboxes();
            this.drawHUD();
        }
        
        drawHUD() {
            const ctx = this.ctx;
            // Health Bar
            ctx.fillStyle = 'gray';
            ctx.fillRect(10, 10, 200, 20);
            ctx.fillStyle = 'red';
            ctx.fillRect(10, 10, (this.player.health / this.player.maxHealth) * 200, 20);
            ctx.fillStyle = 'white';
            ctx.font = "14px 'Press Start 2P'";
            ctx.fillText(`${Math.ceil(this.player.health)}`, 220, 28);
            
            // XP Bar
            ctx.fillStyle = 'gray';
            ctx.fillRect(10, 35, this.canvas.width - 20, 10);
            ctx.fillStyle = 'cyan';
            ctx.fillRect(10, 35, (this.player.xp / this.player.xpToNextLevel) * (this.canvas.width - 20), 10);
            ctx.fillStyle = 'white';
            ctx.font = "16px 'Press Start 2P'";
            ctx.fillText(`LVL: ${this.player.level}`, 15, 70);

            // Timer
            const minutes = Math.floor(this.gameTimer / 60);
            const seconds = Math.floor(this.gameTimer % 60);
            const timerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            ctx.font = "24px 'Press Start 2P'";
            ctx.textAlign = 'center';
            ctx.fillText(timerText, this.canvas.width / 2, 30);
            
            // Kills
            ctx.textAlign = 'right';
            ctx.fillText(`Kills: ${this.totalKills}`, this.canvas.width - 15, 30);
            ctx.textAlign = 'left'; // Reset
        }

        // --- Props and Debug ---
        initProps() {
            const count = CONFIG.PROPS_COUNT || 200;
            const radius = Math.max(this.canvas.width, this.canvas.height) * 5;
            const cx = (this.player?.x || this.canvas.width/2);
            const cy = (this.player?.y || this.canvas.height/2);
            for (let i = 0; i < count; i++) {
                const tpl = choice(PROP_TEMPLATES);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                this.props.push(new Prop(x, y, tpl));
            }
        }
        drawProps() {
            const cam = this.camera; const w = this.canvas.width; const h = this.canvas.height;
            const margin = 200;
            this.props.forEach(p => {
                const px = p.x - cam.x; const py = p.y - cam.y;
                if (px + p.width/2 < -margin || px - p.width/2 > w + margin || py + p.height/2 < -margin || py - p.height/2 > h + margin) return;
                p.draw(this.ctx, this.camera);
            });
        }
        drawHitboxes() {
            if (!(this.debug.charHitbox || this.debug.weaponHitbox)) return;
            if (this.state !== 'playing' && this.state !== 'paused') return;
            const cam = this.camera;
            if (this.debug.charHitbox && this.player) {
                this.drawRectHitbox(this.player, 'rgba(255,0,0,0.9)');
            }
            if (this.debug.weaponHitbox) {
                // Projectiles
                this.projectiles.forEach(p => this.drawRectHitbox(p, 'rgba(255,255,0,0.9)'));
                // Damage areas (holy water)
                this.damageAreas.forEach(a => this.drawCircleHitbox(a.x - cam.x, a.y - cam.y, a.width/2, 'rgba(0,255,255,0.9)'));
                // Aura / Orbit / Whip
                this.player.weapons.forEach(w => {
                    const stats = w.getStats();
                    if (w.data.type === 'aura') {
                        this.drawCircleHitbox(this.player.x - cam.x, this.player.y - cam.y, stats.area, 'rgba(0,255,0,0.9)');
                    } else if (w.data.type === 'orbit') {
                        for (let i = 0; i < stats.amount; i++) {
                            const angle = w.orbitAngle + (i * (2 * Math.PI / stats.amount));
                            const x = this.player.x + Math.cos(angle) * stats.orbitRadius;
                            const y = this.player.y + Math.sin(angle) * stats.orbitRadius;
                            const box = { x, y, width: 40, height: 60 };
                            this.drawRectHitbox(box, 'rgba(0,128,255,0.9)');
                        }
                    } else if (w.data.type === 'attack') {
                        (w.attackEffects||[]).forEach(e => {
                            const box = { x: e.x, y: e.y, width: e.w, height: e.h };
                            this.drawRectHitbox(box, 'rgba(255,128,0,0.9)');
                        });
                    }
                });
            }
        }
        drawRectHitbox(obj, color) {
            const ctx = this.ctx; const cam = this.camera;
            const x = obj.x - (obj.width||0)/2 - cam.x;
            const y = obj.y - (obj.height||0)/2 - cam.y;
            const w = obj.width||0; const h = obj.height||0;
            // Optional overlay texture: assets/ui/hitbox_rect.png
            if (!this.hitboxImg) {
                this.hitboxImg = new Image();
                this.hitboxImg.onload = () => { this.hitboxReady = true; };
                this.hitboxImg.src = 'assets/ui/hitbox_rect.png';
            }
            if (this.hitboxReady) {
                ctx.drawImage(this.hitboxImg, x, y, w, h);
            } else {
                ctx.save();
                ctx.setLineDash([6,4]);
                ctx.strokeStyle = color || 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                ctx.restore();
            }
        }
        drawCircleHitbox(sx, sy, r, color) {
            const ctx = this.ctx;
            ctx.save();
            ctx.setLineDash([6,4]);
            ctx.strokeStyle = color || 'red';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(sx, sy, r, 0, Math.PI*2);
            ctx.stroke();
            ctx.restore();
        }

        // --- Object Management ---
        addProjectile(p) { this.projectiles.push(p); }
        addDamageArea(a) { this.damageAreas.push(a); }
        spawnChest() {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(this.canvas.width, this.canvas.height) * 0.75;
            const x = this.player.x + Math.cos(angle) * radius;
            const y = this.player.y + Math.sin(angle) * radius;
            this.chests.push(new ChestBox(x, y));
        }
        spawnFood(x, y) {
            this.foods.push(new FoodItem(x, y));
        }
        findNearestEnemy(x, y) {
            let nearest = null;
            let nearestDist = Infinity;
            this.enemies.forEach(e => {
                const dist = Math.hypot(e.x - x, e.y - y);
                if(dist < nearestDist) {
                    nearestDist = dist;
                    nearest = e;
                }
            });
            return nearest;
        }
        createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                this.particles.push(new Particle(x, y, color));
            }
        }
        
        // --- UI Handling ---
        
        initUI() {
            this.uiScreens = {
                'main-menu': document.getElementById('main-menu'),
                'character-selection': document.getElementById('character-selection'),
                'pause-screen': document.getElementById('pause-screen'),
                'level-up-screen': document.getElementById('level-up-screen'),
                'game-over-screen': document.getElementById('game-over-screen'),
                'almanac-screen': document.getElementById('almanac-screen'),
            };

            document.getElementById('start-game-button').addEventListener('click', () => {
                this.state = 'character-selection';
                this.updateCharacterSelectionUI(); // Calling the updated UI function
                this.showScreen('character-selection');
            });
            document.getElementById('almanac-button').addEventListener('click', () => {
                this.state = 'almanac';
                this.updateAlmanacUI();
                this.showScreen('almanac-screen');
            });
            
            document.getElementById('resume-button').addEventListener('click', () => {
                this.state = 'playing';
                this.showScreen('none');
            });
            
             document.getElementById('quit-button').addEventListener('click', () => {
                this.state = 'quit';
                this.showScreen('main-menu');
            });
            
            document.getElementById('restart-button').addEventListener('click', () => {
                 this.state = 'character-selection';
                 this.updateCharacterSelectionUI();
                 this.showScreen('character-selection');
            });
            document.getElementById('almanac-back-button').addEventListener('click', () => {
                this.stopAlmanacPreview();
                this.state = 'main-menu';
                this.showScreen('main-menu');
            });
            // Hitbox checkbox listeners
            const charCb = document.getElementById('toggle-char-hitbox');
            const wepCb = document.getElementById('toggle-weapon-hitbox');
            if (charCb) charCb.addEventListener('change', (e) => { this.debug.charHitbox = e.target.checked; });
            if (wepCb) wepCb.addEventListener('change', (e) => { this.debug.weaponHitbox = e.target.checked; });

            this.resize();
            window.addEventListener('resize', () => this.resize());
        }
        
        resize() {
            this.canvas.width = window.innerWidth * 0.9;
            this.canvas.height = window.innerHeight * 0.9;
            const container = document.getElementById('game-container');
            container.style.width = `${this.canvas.width}px`;
            container.style.height = `${this.canvas.height}px`;
        }

        showScreen(screenName) {
            Object.values(this.uiScreens).forEach(screen => screen.classList.add('hidden'));
            if(screenName !== 'none' && this.uiScreens[screenName]) {
                this.uiScreens[screenName].classList.remove('hidden');
            }
            if (screenName !== 'almanac-screen') {
                this.stopAlmanacPreview?.();
            }
            const opts = document.getElementById('play-options');
            if (opts) {
                if (this.state === 'playing' || this.state === 'paused') opts.classList.remove('hidden');
                else opts.classList.add('hidden');
            }
        }
        
        // --- NEW CHARACTER SELECTION UI LOGIC ---
        updateCharacterSelectionUI() {
            const container = document.getElementById('character-options');
            container.innerHTML = '';

            CHARACTERS.forEach((char, index) => {
                const weaponData = WEAPONS[char.startingWeapon];
                let weaponIconSrc = '';
                if (weaponData) {
                    if (weaponData.attackSprite) weaponIconSrc = weaponData.attackSprite;
                    else if (weaponData.projectile && weaponData.projectile.sprite) weaponIconSrc = weaponData.projectile.sprite;
                    else if (weaponData.auraSprite) weaponIconSrc = weaponData.auraSprite;
                    else if (weaponData.orbitSprite) weaponIconSrc = weaponData.orbitSprite;
                }
                
                // Visual Stats
                const maxHpVal = 120;
                const maxSpdVal = 250;
                const hpPercent = Math.min(100, (char.stats.maxHealth / maxHpVal) * 100);
                const spdPercent = Math.min(100, (char.stats.speed / maxSpdVal) * 100);
                let gemColor = char.themeColor || '#c0392b';
                const animDelay = index * 0.2;

                const wrapper = document.createElement('div');
                wrapper.className = 'card-wrapper';
                
                wrapper.innerHTML = `
                    <div class="card" style="border-color: #8c7a6b;">
                        <div class="portrait-bg">
                            <img src="${char.sprite}" class="character-sprite" alt="${char.name}" style="animation-delay: ${animDelay}s">
                            <div class="weapon-box">
                                ${weaponIconSrc ? `<img src="${weaponIconSrc}" class="weapon-sprite" alt="Weapon">` : '<span style="color:white; font-size:10px;">?</span>'}
                            </div>
                        </div>
                        <h3 class="char-name">${char.name}</h3>
                        <p class="char-desc">Weapon: ${char.startingWeapon}</p>
                        <div class="stats-container">
                            <div class="stat-row">
                                <span>HP: ${char.stats.maxHealth}</span>
                                <div class="stat-bar-container"><div class="stat-fill" style="width: ${hpPercent}%"></div></div>
                            </div>
                            <div class="stat-row">
                                <span>SPD: ${char.stats.speed}</span>
                                <div class="stat-bar-container"><div class="stat-fill speed" style="width: ${spdPercent}%"></div></div>
                            </div>
                        </div>
                    </div>
                    <div class="pedestal"><div class="gem" style="background:${gemColor}; box-shadow: 0 0 10px ${gemColor};"></div></div>
                `;

                wrapper.onclick = () => this.startGame(char);
                container.appendChild(wrapper);
            });
        }

        updateAlmanacUI() {
            const left = document.getElementById('almanac-left');
            left.innerHTML = '';
            const keys = Object.keys(ENEMIES);
            keys.forEach(key => {
                const data = ENEMIES[key];
                const card = document.createElement('div');
                card.className = 'almanac-card';
                const thumb = document.createElement('div');
                thumb.className = 'almanac-thumb';
                thumb.style.background = data.spriteColor || '#555';
                const img = new Image();
                img.src = data.sprite;
                img.onerror = () => {};
                thumb.appendChild(img);
                const name = document.createElement('div');
                name.style.marginTop = '6px';
                name.textContent = data.name;
                name.style.color = '#ecf0f1';
                name.style.fontSize = '0.7rem';
                card.appendChild(thumb);
                card.appendChild(name);
                card.onclick = () => this.showAlmanacEntry(key, card);
                left.appendChild(card);
            });
            if (keys.length > 0) {
                const firstCard = left.querySelector('.almanac-card');
                if (firstCard) firstCard.click();
            }
        }

        showAlmanacEntry(key, cardEl) {
            const left = document.getElementById('almanac-left');
            left.querySelectorAll('.almanac-card').forEach(c => c.classList.remove('selected'));
            if (cardEl) cardEl.classList.add('selected');
            const data = ENEMIES[key];
            const title = document.getElementById('almanac-title');
            const lore = document.getElementById('almanac-lore');
            title.textContent = data.name;
            lore.textContent = data.lore || 'No lore available.';
            this.startAlmanacPreview(data);
        }

        startAlmanacPreview(enemyData) {
            this.stopAlmanacPreview();
            const canvas = document.getElementById('almanac-anim-canvas');
            const ctx = canvas.getContext('2d');
            if (ctx) { ctx.imageSmoothingEnabled = false; }
            const anim = enemyData.animations && enemyData.animations.walk;
            const img = new Image();
            const hasSheet = !!(anim && anim.src);
            const src = hasSheet ? anim.src : enemyData.sprite;
            const fps = hasSheet ? (anim.fps || 8) : 1;
            const frames = hasSheet ? (anim.frames || 1) : 1;
            const fw = hasSheet ? anim.frameWidth : null;
            const fh = hasSheet ? anim.frameHeight : null;
            const state = { img, hasSheet, fps, frames, frame: 0, timer: 0, fw, fh };
            
            img.onload = () => {
                if (!state.hasSheet) {
                    state.fw = img.width;
                    state.fh = img.height;
                }
                const loop = (t) => {
                    if (!this.almanacAnim) return;
                    if (!this.almanacLastT) this.almanacLastT = t;
                    const dt = (t - this.almanacLastT) / 1000;
                    this.almanacLastT = t;
                    state.timer += dt;
                    const frameTime = 1 / Math.max(1, state.fps);
                    if (state.hasSheet) {
                        while (state.timer >= frameTime) {
                            state.timer -= frameTime;
                            state.frame = (state.frame + 1) % state.frames;
                        }
                    }
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const scale = Math.min(canvas.width / state.fw, canvas.height / state.fh);
                    const dw = state.fw * scale;
                    const dh = state.fh * scale;
                    const dx = (canvas.width - dw) / 2;
                    const dy = (canvas.height - dh) / 2;
                    const sx = state.hasSheet ? state.frame * state.fw : 0;
                    const sy = 0;
                    ctx.drawImage(state.img, sx, sy, state.fw, state.fh, dx, dy, dw, dh);
                    this.almanacAnimRAF = requestAnimationFrame(loop);
                };
                this.almanacAnimRAF = requestAnimationFrame(loop);
            };
            
            // Fallback for missing Boss_walk images so it doesn't break
            img.onerror = () => {
                if (state.hasSheet) {
                    state.hasSheet = false; // Fallback to static mode
                    state.img.src = enemyData.sprite; // Load static sprite instead
                }
            };
            
            img.src = src;
            this.almanacAnim = state;
        }

        stopAlmanacPreview() {
            if (this.almanacAnimRAF) cancelAnimationFrame(this.almanacAnimRAF);
            this.almanacAnimRAF = null;
            this.almanacAnim = null;
            this.almanacLastT = null;
            const canvas = document.getElementById('almanac-anim-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx && ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
        
        generateLevelUpOptions() {
            const options = [];
            const availableWeapons = Object.keys(WEAPONS).filter(w => !this.player.weapons.some(p_w => p_w.name === w) && this.player.weapons.length < 6);
            const upgradableWeapons = this.player.weapons.filter(w => w.level < w.data.levels.length);
            const availablePassives = Object.keys(PASSIVES).filter(p => {
                const currentLevel = this.player.passives[p]?.level || 0;
                return currentLevel < PASSIVES[p].levels.length;
            });

            // Add an existing weapon to upgrade
            if (upgradableWeapons.length > 0) {
                options.push({ type: 'weapon', data: choice(upgradableWeapons) });
            }

            // Add a new weapon to acquire
            if (availableWeapons.length > 0) {
                options.push({ type: 'new_weapon', name: choice(availableWeapons) });
            }
            
            // Add passives
            while(options.length < 3 && availablePassives.length > 0) {
                 const passiveName = choice(availablePassives);
                 if(!options.some(o => o.type === 'passive' && o.name === passiveName)) {
                    options.push({ type: 'passive', name: passiveName });
                 }
            }
            
            // Fill remaining with more weapon upgrades or passives if possible
             while(options.length < 3) {
                 const pool = [];
                 if(upgradableWeapons.length > 0) pool.push('weapon');
                 if(availablePassives.length > 0) pool.push('passive');
                 if(pool.length === 0) break; // No more options
                 
                 const type = choice(pool);
                 if(type === 'weapon') {
                    const wep = choice(upgradableWeapons);
                    if(!options.some(o => o.data?.name === wep.name)) options.push({ type: 'weapon', data: wep });
                 } else {
                    const pas = choice(availablePassives);
                    if(!options.some(o => o.name === pas)) options.push({ type: 'passive', name: pas });
                 }
             }

            this.updateLevelUpUI(options);
            this.showScreen('level-up-screen');
        }

        updateLevelUpUI(options) {
            const container = document.getElementById('upgrade-options');
            container.innerHTML = '';
            options.forEach(option => {
                const card = document.createElement('div');
                card.className = 'upgrade-card';
                let html = '';
                
                switch(option.type) {
                    case 'weapon':
                        const nextLevel = option.data.level;
                        const nextLevelInfo = option.data.data.levels[nextLevel].info;
                        html = `
                            <h3>${option.data.name}</h3>
                            <p class="level">LVL ${nextLevel + 1}</p>
                            <p>${nextLevelInfo}</p>
                        `;
                        card.onclick = () => this.selectUpgrade(option);
                        break;
                    case 'new_weapon':
                        html = `
                            <h3>${option.name}</h3>
                            <p class="level">NEW</p>
                            <p>${WEAPONS[option.name].levels[0].info}</p>
                        `;
                        card.onclick = () => this.selectUpgrade(option);
                        break;
                    case 'passive':
                        const currentLevel = this.player.passives[option.name]?.level || 0;
                        const passiveData = PASSIVES[option.name];
                        html = `
                            <h3>${passiveData.name}</h3>
                            <p class="level">LVL ${currentLevel + 1}</p>
                            <p>${passiveData.levels[currentLevel].info}</p>
                        `;
                        card.onclick = () => this.selectUpgrade(option);
                        break;
                }
                card.innerHTML = html;
                container.appendChild(card);
            });
        }
        
        selectUpgrade(option) {
             switch(option.type) {
                case 'weapon':
                    option.data.levelUp();
                    break;
                case 'new_weapon':
                    this.player.addWeapon(option.name);
                    break;
                case 'passive':
                    this.player.addPassive(option.name);
                    break;
            }
            this.state = 'playing';
            this.showScreen('none');
        }

        updateGameOverUI() {
            const container = document.getElementById('game-over-stats');
            const survivedTime = `${Math.floor(this.gameTimer / 60).toString().padStart(2, '0')}:${Math.floor(this.gameTimer % 60).toString().padStart(2, '0')}`;
            container.innerHTML = `
                <p><span>Time Survived:</span> <span>${survivedTime}</span></p>
                <p><span>Enemies Defeated:</span> <span>${this.totalKills}</span></p>
                <p><span>Final Level:</span> <span>${this.player.level}</span></p>
            `;
        }

        // --- Input Handling ---
        initInput() {
            window.addEventListener('keydown', e => {
                this.keys[e.key] = true;
                if (e.key === 'Escape' && this.state === 'playing') {
                    this.state = 'paused';
                    this.showScreen('pause-screen');
                } else if (e.key === 'Escape' && this.state === 'paused') {
                    this.state = 'playing';
                    this.showScreen('none');
                }
            });
            window.addEventListener('keyup', e => {
                this.keys[e.key] = false;
            });
        }
    }
    
    // --- Particle Class for FX ---
    class Particle extends GameObject {
        constructor(x, y, color) {
            super(x, y, randInt(4,10), randInt(4,10));
            this.lifespan = 1;
            this.vx = rand(-100, 100);
            this.vy = rand(-100, 100);
            this.color = color;
        }

        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.lifespan -= dt;
            if (this.lifespan <= 0) this.active = false;
        }

        draw(ctx, camera) {
            ctx.globalAlpha = this.lifespan;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x - this.width / 2 - camera.x, this.y - this.height / 2 - camera.y, this.width, this.height);
            ctx.globalAlpha = 1.0;
        }
    }


    // --- Game Initialization ---
    const canvas = document.getElementById('game-canvas');
    const game = new Game(canvas);
    
    // Listen for level-up events
    Object.defineProperty(game, 'state', {
        get: function() { return this._state; },
        set: function(newState) {
            this._state = newState;
            if(newState === 'level-up') {
                this.generateLevelUpOptions();
            }
        }
    });

    </script>
</body>
</html>